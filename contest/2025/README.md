# TurkeyBox - CoContest (SP_CC_R)

This project implements a solution for the **TurkeyBox** problem in the **SP_CC_R** (ranking) category of the CoContest. The objective is to place rectangular items from multiple customers into lockers to maximize profit, defined as the sum of item payments and customer bonuses, within a given time limit.

> [!NOTE]
> The README file was generated by Grog 3 AI mode based on Assignment pdf and code solution.

## Problem Description

The TurkeyBox problem involves assigning rectangular items to rectangular lockers to maximize the total profit while adhering to specific constraints. The rules are:

- **Lockers**: A set of `M` lockers, each with a unique index, width, and height.
- **Customers**: A set of `N` customers, each with a list of items and a bonus payment.
- **Items**: Each item has a payment, width, and height. Items can be rotated (0° or 90°) to fit into lockers.
- **Constraints**:
  - A locker can contain items from only one customer.
  - Multiple items can be placed in a single locker, provided they fit without overlapping and respect the locker's dimensions.
  - Each customer can be assigned multiple lockers.
  - Items must fit within the locker's width and height.
- **Objective**: Maximize the total profit, which includes:
  - Payments for all placed items (sum of `payment` for items with `locker_id > 0`).
  - Bonuses for customers whose all items are placed in lockers.
- **SP_CC_R Specifics**: The solution is evaluated based on the objective value (higher is better) within a 1-second time limit. The ranking category prioritizes high objective values, even if the solution may not be optimal.

## Data Structure

### Input Format
The input is provided in a text file with the following structure:
- **First line**: `M N` (number of lockers `M` and customers `N`).
- **Second line**: `n_1 n_2 ... n_N` (number of items for each customer).
- **Next `M` lines**: `w_i h_i` (width and height of locker `i`).
- **Next `N` blocks** (for each customer `i`):
  - `b_i` (bonus for customer `i`).
  - `n_i` lines, each with `p_j w_j h_j` (payment, width, and height of item `j`).

### Output Format
The output is written to a text file with:
- **First line**: The objective value (sum of payments and bonuses).
- **Next lines**: Placement of each item in the order of input: `locker_id x y rotated`, where:
  - `locker_id`: 1-based index of the locker (0 if unplaced).
  - `x`, `y`: Bottom-left coordinates of the item in the locker.
  - `rotated`: 0 (no rotation) or 1 (90° rotation).

### Example Input
```
4 5
30 23 23 23 33
20 15
10 10
15 15
12 12
944
100 3 3
...
93
200 4 4
...
```

### Example Output
```
3091
1 0 0 0
0 0 0 0
...
```

## Algorithms Used

The solution combines a **skyline algorithm** for item placement within lockers and a **heuristic optimization** to maximize the objective value. Below is a detailed description of the algorithms implemented in `main.cpp` and `main.h`.

### 1. Skyline Algorithm (`Locker::put_order`)
The skyline algorithm manages the placement of items in a locker, ensuring they fit without overlapping (though the current implementation may allow some overlaps) and respect the single-customer constraint.

- **Purpose**: Determines if an item can be placed in a locker at a specific position and rotation, updating the locker's occupied space.
- **Data Structure**:
  - The `skyline` is a vector of `(x, height)` pairs, where `height` is the highest occupied point at x-coordinate `x` in the locker.
  - Initially, the skyline is flat (height 0 for all x).
- **Process**:
  1. **Customer Check**: Verifies that the locker is either empty (`customer_id = 0`) or assigned to the same customer as the item.
  2. **Rotation Trials**: Attempts to place the item in two orientations (0° and 90°), swapping width and height for the rotated case.
  3. **Position Search**:
     - Iterates over possible x-coordinates (`x` from 0 to `locker_width - item_width`).
     - Computes `max_height` as the maximum skyline height in the range `[x, x + item_width)`.
     - Checks if the item fits vertically (`max_height + item_height <= locker_height`).
     - Performs two overlap checks:
       - Ensures no skyline point in `[x, x + item_width)` has a height greater than `max_height`.
       - Additional check iterates over each x-coordinate to confirm no existing items extend into the placement area.
  4. **Placement**:
     - Selects the position with the lowest `max_height` to place the item as low as possible.
     - Updates the item's `locker_id` (1-based), `x`, `y`, and `rotated` fields.
     - Rebuilds the skyline by setting the height to `y + item_height` in `[x, x + item_width)` and preserving existing heights elsewhere.
  5. **Customer Assignment**: Sets the locker's `customer_id` to the item's customer ID.
- **Output**: Returns `true` if the item was placed, `false` otherwise.
- **Note**: The overlap check may be insufficient, potentially allowing items to overlap, which inflates the objective value (e.g., 3091 vs. reference ~2400). A more robust check could ensure validity.

### 2. Heuristic Optimization (`Solver::solve`)
The solver uses an iterative heuristic to explore different item placements and maximize the objective value within the time limit.

- **Purpose**: Places items in lockers to maximize the sum of payments and bonuses, using randomization to test multiple configurations.
- **Process**:
  1. **Initialization**:
     - Tracks the best solution (highest objective, item placements, and locker states).
     - Seeds the random number generator with the current time for varied results.
  2. **Iterations** (until 95% of the time limit is reached):
     - Resets the objective, lockers, and item assignments to the best known state.
     - **Customer Prioritization**:
       - Computes a profit density for each customer: `(bonus + sum of item payments) / sum of item areas`.
       - Sorts customers by density in descending order and applies a random shuffle to introduce variability.
     - **Item Placement**:
       - For each customer, sorts their items by profit density (`payment / area`) in descending order.
       - Attempts to place each item in a locker using `put_order`, trying lockers sequentially.
       - If an item is placed, adds its payment to the objective and increments the placed items counter (in debug mode).
       - If placement fails, resets the item's assignment (`locker_id = 0`, `x = 0`, `y = 0`, `rotated = 0`).
     - **Bonus Assignment**:
       - If all items for a customer are placed, verifies their validity (all `locker_id > 0`).
       - Adds the customer's bonus to the objective if valid.
     - **Solution Update**:
       - If the current objective exceeds the best known, updates the best solution (objective, order list, lockers).
       - Outputs debug information (iteration, objective, number of placed items) if `DEBUG` is defined.
  3. **Finalization**: Sets the final solution to the best found, updating the solver's `objective`, `order_list`, and `lockers`.
- **Randomization**: The random shuffle of customer priorities ensures diverse solutions, increasing the likelihood of finding a high-objective configuration.
- **Time Management**: Uses 95% of the time limit for iterations, reserving 5% for final processing and output.

**Strengths**:
- The skyline algorithm efficiently manages item placement within lockers.
- Randomization allows exploration of multiple configurations, suitable for the SP_CC_R ranking goal.
- Profit density prioritization focuses on high-value items and customers.

**Weaknesses**:
- The overlap check in `put_order` may allow invalid placements, leading to inflated objective values.
- The heuristic prioritizes density over high-bonus customers, potentially missing large bonuses (e.g., 944 for a customer with 30 items).
- Limited time (95% of 1 second) may not explore all high-value configurations.

## Building and Running

### Prerequisites
- C++ compiler supporting C++11 or later (e.g., `g++`).
- CMake (version 3.10 or higher).

### Commands
```sh
# Build the binary
cmake --build . -- -j

# Run the binary
./TurkeyBox <input_path> <output_path> <time_limit>

# Example: Run with a 1-second time limit
./TurkeyBox dataset/threshold/1.ins tmp.txt 1.00

# Create a zip file with source code
cmake --build . --target zip_sources

# Build and run in one step
cmake --build . -- -j && ./TurkeyBox dataset/threshold/1.ins tmp.txt 1.00
```

## Project Structure
- **`main.h`**: Header file defining classes:
  - `Size`: Base class for width and height.
  - `Order`: Represents an item with payment, dimensions, and placement details.
  - `OrderList`: Manages a customer's items and bonus.
  - `Locker`: Represents a locker with dimensions, customer assignment, and skyline.
  - `Solver`: Orchestrates the heuristic optimization.
- **`main.cpp`**: Implementation of:
  - Input parsing and validation.
  - Skyline algorithm (`Locker::put_order`).
  - Heuristic optimization (`Solver::solve`).
  - Output generation.
- **`dataset/`**: Directory for input files (e.g., `threshold/1.ins`).
- **`CMakeLists.txt`**: CMake configuration for building the project.

## Usage
1. Place input files in the `dataset/` directory (e.g., `dataset/threshold/1.ins`).
2. Build the project using CMake.
3. Run the binary with the input file, output file, and time limit (e.g., `1.00` seconds).
4. Check the output file (e.g., `tmp.txt`) for the objective value and item placements.
5. For debugging, define `DEBUG` in `main.h` to enable iteration logs.

## Performance Notes
- The implementation achieves objective values around 3091 (vs. reference ~2400), but this may be due to invalid placements (overlapping items).
- The skyline algorithm and heuristic are effective for SP_CC_R, but the overlap check needs improvement for valid solutions.
- Typical runtime is under 1 second, fitting the time limit.

## Future Improvements
- **Overlap Validation**: Implement a `validate_no_overlap` method in `Locker` to ensure items do not overlap, guaranteeing valid solutions.
- **Enhanced Heuristic**:
  - Prioritize customers by bonus or item count to target high-value bonuses (e.g., 944).
  - Try multiple prioritization strategies (e.g., largest items first) within iterations.
- **Skyline Optimization**: Merge adjacent skyline points with the same height to reduce computation.
- **Parallelization**: Use multi-threading to explore more configurations within the time limit.

## Submission
To submit the solution to the BRUTE platform:
1. Generate the output file (e.g., `tmp.txt`).
2. Validate the output format and objective value.
3. Upload the output file to https://cw.felk.cvut.cz/brute/ for evaluation.